package bandersnatch

import (
	"fmt"
	"io"
	"math/big"
)

// Curve parameters

// Order of the p253-subgroup of the Bandersnatch curve. This is a 253-bit prime.
const (
	GroupOrder        = 0x1cfb69d4ca675f520cce760202687600ff8f87007419047174fd06b52876e7e1
	GroupOrder_string = "0x1cfb69d4ca675f520cce760202687600ff8f87007419047174fd06b52876e7e1"
)

const Cofactor = 4
const CurveOrder = Cofactor * GroupOrder

var GroupOrder_Int *big.Int = initIntFromString(GroupOrder_string)
var Cofactor_Int *big.Int = big.NewInt(Cofactor)
var CurveOrder_Int *big.Int = new(big.Int).Mul(GroupOrder_Int, Cofactor_Int)

const (
	EndomorphismEivenvalue        = 0x13b4f3dc4a39a493edf849562b38c72bcfc49db970a5056ed13d21408783df05
	EndomorphismEigenvalue_string = "0x13b4f3dc4a39a493edf849562b38c72bcfc49db970a5056ed13d21408783df05"
)

var EndomorphismEigenvalue_Int *big.Int = initIntFromString(EndomorphismEigenvalue_string)

// parameters a, d in twisted Edwards form ax^2 + y^2 = 1 + dx^2y^2

// Note: both a and d are non-squares

const CurveParameterA = -5
const (
	CurveParameterD        = 0x6389c12633c267cbc66e3bf86be3b6d8cb66677177e54f92b369f2f5188d58e7
	CurveParameterD_string = "0x6389c12633c267cbc66e3bf86be3b6d8cb66677177e54f92b369f2f5188d58e7"
)

var (
	CurveParameterD_Int *big.Int     = initIntFromString(CurveParameterD_string)
	CurveParameterD_fe  FieldElement = initFieldElementFromString(CurveParameterD_string)
)

// squareRootDByA is a square root of d/a. Due to the way the bandersnatch curve was constructed, we have (sqrt(d/a) + 1)^2 == 2.
// This number appears in coordinates of the order-2 points at inifinity and in the formulae for the endomorphism.
const (
	squareRootDByA        = 37446463827641770816307242315180085052603635617490163568005256780843403514038
	squareRootDByA_string = "37446463827641770816307242315180085052603635617490163568005256780843403514038"
)

var (
	// squareRootDbyA_Int *big.Int     = initIntFromString(squareRootDByA_string) // TODO: Do we need this?
	squareRootDbyA_fe FieldElement = initFieldElementFromString(squareRootDByA_string)
)

/*
	Caveat: Bandersnatch is typically represented as a twisted Edwards curve, which means there are singularities
	at infinity. These singularities are not in the large-prime order subgroup. (the cofactor is 4)
	and only really correspond to curve points after desingularization anyway.

	To avoid these issues, we shall assert (and check on external input) that all points in the correct subgroup, which we
	represent as G' modulo P=P+A, where G' is the subgroup of rational point that is generated by the prime-order subgroup
	and the affine order-2 point A.
	Effectively, this means that we need to ensure that all points are in G' and that we work modulo A.

	Note that all non-comparison operations actually give the correct result even when not working modulo A.
	Unless explicitly specified otherwise, we do not guarantee correctness on our algorithms for points outside the subgroup G'.
*/

// A CurvePoint represents a rational point on the bandersnatch curve in the correct subgroup.

type CurvePointRead interface {
	X_projective() FieldElement
	Y_projective() FieldElement
	// T_Projective() FieldElement
	Z_projective() FieldElement

	X_affine() FieldElement // TODO: Consider removal
	Y_affine() FieldElement // TODO: Consider removal
	// T_affine() FieldElement
	// Z_affine == 1

	IsNeutralElement() bool
	IsNeutralElement_exact() bool
	// IsAffine() bool // TODO: Consier removal / renaming
	// MakeAffine()    // TODO: Consider removal / renaming
	IsEqual(CurvePointRead) bool
	IsEqual_exact(CurvePointRead) bool
	IsAtInfinity() bool
	IsNaP() bool

	AffineExtended() Point_axtw
	ExtendedTwistedEdwards() Point_xtw
	Clone() CurvePointRead

	SerializeShort(output io.Writer) (bytes_written int, err error)
	SerializeLong(output io.Writer) (bytes_written int, err error)

	fmt.Stringer // i.e. Stringer() string
}

type CurvePointWrite interface {
	Add(CurvePointRead, CurvePointRead)
	Sub(CurvePointRead, CurvePointRead)
	Double(CurvePointRead)
	Neg(CurvePointRead)
	Endo(CurvePointRead)
	Endo_fullCurve(CurvePointRead)

	SetNeutral()

	AddEq(CurvePointRead)
	SubEq(CurvePointRead)
	DoubleEq()
	NegEq()
	EndoEq()

	SetFrom(CurvePointRead)

	DeserializeShort(input io.Reader, trusted bool) (bytes_read int, err error)
	DeserializeLong(input io.Reader, trusted bool) (bytes_read int, err error)
	DeserializeAuto(input io.Reader, trusted bool) (bytes_read int, err error)
	// ClearCofactor()
}

type CurvePoint interface {
	CurvePointRead
	CurvePointWrite
}

// Note: Some of these are unused. Make consistent with Bandersnatch paper.

// These parameters appear in the formulae for the endomorphism.
const (
	// endo_a1              = 0x23c58c92306dbb95960f739827ac195334fcd8fa17df036c692f7ddaa306c7d4
	// endo_a1_string       = "0x23c58c92306dbb95960f739827ac195334fcd8fa17df036c692f7ddaa306c7d4"
	// endo_a2              = 0x23c58c92306dbb96b0b30d3513b222f50d02d8ff03e5036c69317ddaa306c7d4
	// endo_a2_string       = "0x23c58c92306dbb96b0b30d3513b222f50d02d8ff03e5036c69317ddaa306c7d4"
	endo_b               = 0x52c9f28b828426a561f00d3a63511a882ea712770d9af4d6ee0f014d172510b4 // == sqrt(2) - 1 == sqrt(a/d)
	endo_b_string        = "0x52c9f28b828426a561f00d3a63511a882ea712770d9af4d6ee0f014d172510b4"
	endo_binverse        = 0x52c9f28b828426a561f00d3a63511a882ea712770d9af4d6ee0f014d172510b6 // =1/endo_b == endo_b + 2 == sqrt(d/a). Equals sqrtDByA
	endo_binverse_string = "0x52c9f28b828426a561f00d3a63511a882ea712770d9af4d6ee0f014d172510b6"
	endo_bcd_string      = "36255886417209629651405037489028103282266637240540121152239675547668312569901" // == endo_b * endo_c * CurveParameterD
	endo_c               = 0x6cc624cf865457c3a97c6efd6c17d1078456abcfff36f4e9515c806cdf650b3d
	endo_c_string        = "0x6cc624cf865457c3a97c6efd6c17d1078456abcfff36f4e9515c806cdf650b3d"
	// endo_c1 == - endo_b
	//c1 = 0x2123b4c7a71956a2d149cacda650bd7d2516918bf263672811f0feb1e8daef4d
)

var (
	// endo_a1_fe       FieldElement = initFieldElementFromString(endo_a1_string)
	// endo_a2_fe       FieldElement = initFieldElementFromString(endo_a2_string)
	endo_b_fe        FieldElement = initFieldElementFromString(endo_b_string)
	endo_c_fe        FieldElement = initFieldElementFromString(endo_c_string)
	endo_binverse_fe FieldElement = initFieldElementFromString(endo_binverse_string) // Note == SqrtDDivA_fe
	endo_bcd_fe      FieldElement = initFieldElementFromString(endo_bcd_string)
)
