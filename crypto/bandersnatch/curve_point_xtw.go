package bandersnatch

import (
	"fmt"
	"math/big"
)

// Point_xtw describes points on the p253-subgroup of the Bandersnatch curve in extended twisted Edwards coordinates.
// Extended means that we additionally store T with T = X*Y/Z. Note that Z is never 0 for points in the subgroup, but see code comment about desingularisation.)
// cf. https://iacr.org/archive/asiacrypt2008/53500329/53500329.pdf
type Point_xtw struct {
	x FieldElement
	y FieldElement
	z FieldElement
	t FieldElement
}

/*
	NOTE: Points described by Point_xtw should really been seen as solutions to the set of homogeneous equations

	ax^2 + y^2 = z^2 + dt^2
	x*y = z*t

	with addition law for P3 = P1 + P2 given by:
	X3 = (X1Y2 + Y1X2)(Z1Z2 - dT1T2)
	Y3 = (Y1Y2 - aX1X2)(Z1Z2 + dT1T2)
	T3 = (X1Y2 + Y1X2)(Y1Y2-aX1X2)
	Z3 = (Z1Z2 - dT1T2)(Z1Z2 + dT1T2)

	which we call the extended twisted Edwards model. We treat this as a curve model (like Weierstrass, Montgomery, (twisted) Edwards) rather than a redundant coordinate representaion.

	Clearly, the set of affine solutions corresponds exactly to the set of affine solutions of the usual twisted Edwards equation ax^2 + y^2 = 1+dx^2y^2
	(with z==1, t==x*y), but there are differences in the behaviour at infinity:
	Notably, the twisted Edwards curve has 2+2 points at infinity and the curve is actually singular there:
	Those are double (in the sense that a desingularization results in two points) points at (1:0:0), (0:1:0) each.
	By contrast, the extended twisted Edwards model has no singularities for a != +/-d (over the algebraic closure, to be clear).
	In fact, the additional t coordinate both improves efficiency and is a very convenient desingularization, where things become more clear.
	The (not neccessarily rational) points at infinity (z==0) of this model are in (x:y:t:z) coordinates:
	(0:sqrtz(d):1:0), (0:-sqrt(d):1:0), (sqrt(d/a):0:1:0), (-sqrt(d/a):0:1:0)
	The first two point have order 4 (doubling them gives (0:-1:0:1)), the latter two points have order 2.
	Now, in the case usually considered in the literature, d is a non-square and a is a square.
	Then all these points at infinity are actually not rational and we even get a unified point addition law that works for all rational points.

	In the bandersnatch case, both a and d are non-squares. This means we get two bona-fide rational(!) points at infinity of order 2.
	The addition law above no longer works in all cases. A lengthy analysis (TODO: Make a pdf and write up the proof or find one in literature) shows that the following holds

	Theorem:
	for P,Q rational, the extended Edwards addition law given above for P1 + P2 does not work if and only if P1 - P2 is a (rational, order-2) point at infinity.

	Consequences:
	The addition law works for all points in the subgroup of size 2*p253, generated by the large-prime p253 subgroup and the affine point of order 2.
	If P1,P2 are both contained in a cyclic subgroup generated by Q, then the addition law can only fail in the following cases:
		One of P1,P2 is the neutral element, the other one is equal to Q and is a point at infinity.
		Q has order 2*p253, P1 = alpha * Q, P2 = beta * Q with alpha-beta == p253 mod 2*p253. We can actually ensure that never happens in our exponentiation algorithms.
*/

// example point on the subgroup specified in the bandersnatch paper
var example_generator_x *big.Int = initIntFromString("0x29c132cc2c0b34c5743711777bbe42f32b79c022ad998465e1e71866a252ae18")
var example_generator_y *big.Int = initIntFromString("0x2a6c669eda123e0f157d8b50badcd586358cad81eee464605e3167b6cc974166")
var example_generator_t *big.Int = new(big.Int).Mul(example_generator_x, example_generator_y)
var example_generator_xtw Point_xtw = func() (ret Point_xtw) {
	ret.x.SetInt(example_generator_x)
	ret.y.SetInt(example_generator_y)
	ret.t.SetInt(example_generator_t)
	ret.z.SetOne()
	return
}()

/*
	Basic functions for Point_xtw
*/

// NeutralElement_<foo> denotes the Neutral Element of the Bandersnatch curve.
var (
	NeutralElement_xtw Point_xtw = Point_xtw{x: FieldElementZero, y: FieldElementOne, t: FieldElementZero, z: FieldElementOne}
)

// These are the three points of order 2 that we can represent with extended twisted coordinates. None of these is in the p253-subgroup, of course.
// Although we do not need or use this, note that SqrtDDivA_fe := sqrt(d/a) == sqrt(2) - 1 due to the way the bandersnatch curve was constructed.
var (
	orderTwoPoint_xtw  Point_xtw = Point_xtw{x: FieldElementZero, y: FieldElementMinusOne, t: FieldElementZero, z: FieldElementOne}
	exceptionalPoint_1 Point_xtw = Point_xtw{x: SqrtDDivA_fe, y: bsFieldElement_64_zero, t: FieldElementOne, z: FieldElementZero}
	exceptionalPoint_2 Point_xtw = func() (ret Point_xtw) {
		ret = exceptionalPoint_1
		ret.x.Neg(&ret.x)
		return
	}()
)

// X_affine returns the X coordinate of the given point in affine twisted Edwards coordinates.
func (P *Point_xtw) X_affine() FieldElement {
	P.makeAffine_x()
	return P.x
}

// Y_affine returns the Y coordinate of the given point in affine twisted Edwards coordinates.
func (P *Point_xtw) Y_affine() FieldElement {
	P.makeAffine_x()
	return P.y
}

// T_affine returns the T coordinate (i.e. T=XY) of the given point in affine twisted Edwards coordinates.
func (P *Point_xtw) T_affine() FieldElement {
	P.makeAffine_x()
	return P.t
}

// X_projective returns the X coordinate of the given point P in projective twisted Edwards coordinates.
// Note that calling functions on P other than X_projective(), Y_projective(), Z() might change the representations of P at will,
// so callers must not interleave calling other functions.
func (P *Point_xtw) X_projective() FieldElement {
	return P.x
}

// Y_projective returns the Y coordinate of the given point P in projective twisted Edwards coordinates.
// Note that calling functions on P other than X_projective(), Y_projective(), Z() might change the representations of P at will,
// so callers must not interleave calling other functions.
func (P *Point_xtw) Y_projective() FieldElement {
	return P.y
}

// Z_projective returns the Z coordinate of the given point P in projective twisted Edwards coordinates.
// Note that calling functions on P other than X_projective(), Y_projective(), Z() might change the representations of P at will,
// so callers must not interleave calling other functions.
func (P *Point_xtw) Z_projective() FieldElement {
	return P.z
}

// T_projective returns the T coordinate of the given point P in projective twisted Edwards coordinates (i.e. T = XY/Z).
// Note that calling functions on P other than X_projective(), Y_projective(), Z() might change the representations of P at will,
// so callers must not interleave calling other functions.
func (P *Point_xtw) T_projective() FieldElement {
	return P.t
}

// Q: Should IsAffine and MakeAffine be exported in the first place?
// Note that the names of the function are misleading. NormalizeAffine might be better.
// (In particular, IsAffine might be mistaken for querying whether a point is at infinity or not)

/* In addition, we might consider normalizing to y==1 rather than z==1 */

func (P *Point_xtw) MakeAffine() {
	if !P.IsAffine() {
		P.makeAffine_x()
	}
}

func (p *Point_xtw) IsAffine() bool {
	return p.z.IsOne()
}

// AffineExtended returns a copy of the point in affine extended coordinates.
func (p *Point_xtw) AffineExtended() Point_axtw {
	p.MakeAffine()
	return Point_axtw{x: p.x, y: p.y, t: p.t}
}

// IsZero checks if the point P is the neutral element of the curve. Use IsZero_safe if you do not know a priori that is in the subgroup.
func (P *Point_xtw) IsZero() bool {
	// NOTE: This asserts that P is in the correct subgroup or that we work modulo the affine order-2 point (x=0, y=-c, t=0, z=c).
	return P.x.IsZero()
}

// SetZero sets the Point P to the neutral element of the curve.
func (P *Point_xtw) SetZero() {
	*P = NeutralElement_xtw
}

// IsZero_safe tests for zero-ness even if we do not know that the point is in the subgroup. We only assume that x,y,t,z satisfy the curve equations.
// Returns false for singularity x==y==t==z==0
func (P *Point_xtw) IsZero_safe() bool {
	// We check this separately, because we want that specific behaviour on singularity.
	if P.z.IsZero() {
		// TODO: Check for singularity and log?
		return false
	}
	return P.x.IsZero() && P.t.IsZero() && P.y.IsEqual(&P.z)
}

/*
	Note: Suffixes like _xxx or _xxa refer to the type of input point (with order output, input1 [,input2] )
	x denote extended projective,
	a denotes extended affine
*/

// https://www.hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd, due to Hisil–Wong–Carter–Dawson 2008, http://eprint.iacr.org/2008/522, Section 3.1.
func (out *Point_xtw) add_xxx(input1, input2 *Point_xtw) {
	var A, B, C, D, E, F, G, H FieldElement // We follow the notation of the link above

	A.Mul(&input1.x, &input2.x) // A = X1 * X2
	B.Mul(&input1.y, &input2.y) // B = Y1 * Y2
	C.Mul(&input1.t, &input2.t)
	C.MulEq(&TwistedEdwardsD_fe) // C = d * T1 * T2
	D.Mul(&input1.z, &input2.z)  // D = Z1 * Z2
	E.Add(&input1.x, &input1.y)
	F.Add(&input2.x, &input2.y) // F serves as temporary
	E.MulEq(&F)
	E.SubEq(&A)
	E.SubEq(&B)   // E = (X1 + Y1) * (X2 + Y2) - A - B == X1*Y2 + Y1*X2
	F.Sub(&D, &C) // F = D - C
	G.Add(&D, &C) // G = D + C

	A.multiply_by_five()
	H.Add(&B, &A) // H = B + 5X1 * X2 = Y1*Y2 - a*X1*X2  (a=-5 is a parameter of the curve)

	out.x.Mul(&E, &F) // X3 = E * F
	out.y.Mul(&G, &H) // Y3 = G * H
	out.t.Mul(&E, &H) // T3 = E * H
	out.z.Mul(&F, &G) // Z3 = F * G
}

func (out *Point_xtw) double_xx(input1 *Point_xtw) {
	// TODO: Use https://www.hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd.
	// Note we need to ensure that this formula gives the same result as add_xxx (modulo ax^2 + y^2 = z^2 + dt^2 and a global sign), even for z==0
	out.add_xxx(input1, input1)
}

func (out *Point_xtw) neg_xx(input1 *Point_xtw) {
	out.x = input1.x
	out.y.Neg(&input1.y)
	out.t.Neg(&input1.t)
	out.z = input1.z
}

func (out *Point_xtw) sub_xxx(input1, input2 *Point_xtw) {
	out.neg_xx(input2)
	out.add_xxx(out, input1)
}

// is_equal_xx checks whether two points in the subgroup are equal. On the p523+A subgroup, it checks for equality modulo the affine order-2 point.
func (p1 *Point_xtw) is_equal_xx(p2 *Point_xtw) bool {
	var temp1, temp2 FieldElement
	// We check whether x1/y1 == x2/y2. Note that the map Curve -> Field given by x/y is 2:1 with preimages of the form {P, P+A} for the affine 2 torsion point A.
	temp1.Mul(&p1.x, &p2.y)
	temp2.Mul(&p1.y, &p2.x)
	// TODO: Check special case temp1 == 0 and ensure neither input is singularity.
	return temp1.IsEqual(&temp2)
}

func (p *Point_xtw) makeAffine_x() {
	var temp FieldElement
	if p.z.IsZero() {
		panic("Trying to make point at infinity or singular point affine")
	}
	temp.Inv(&p.z)
	p.x.MulEq(&temp)
	p.y.MulEq(&temp)
	p.t.MulEq(&temp)
	p.z.SetOne()
}

// is_equal_safe_xx checks whether p1 == p2. This works for all rational points (including points at infinity), not only those in the subgroup. It does *not* identify P with P+A
func (p1 *Point_xtw) is_equal_safe_xx(p2 *Point_xtw) bool {
	var temp1, temp2 FieldElement
	if p1.z.IsZero() {
		if !p2.z.IsZero() {
			return false
		}
		// TODO: Check for singularity?
		// z == 0 implies x == 0 and t,y non-zero, so p1.x == p2.x == p1.z == p2.z == 0
		temp1.Mul(&p1.y, &p2.t)
		temp2.Mul(&p1.t, &p2.y)
		return temp1.IsEqual(&temp2)
	}
	if p2.z.IsZero() {
		return false // p1.z != 0, because these cases were already done above.
	}
	// p1, p2 both have z!=0. We need to check both x1/z1 == x2/z2 and y1/z1 == y2/z2
	temp1.Mul(&p1.x, &p2.z)
	temp2.Mul(&p1.z, &p2.x)
	if !temp1.IsEqual(&temp2) {
		return false
	}
	// Note that we actually know that y1/z1 == +/- y2/z2, as the curve equations only has 2 solutions for given y.
	temp1.Mul(&p1.y, &p2.z)
	temp2.Mul(&p1.z, &p2.y)
	return temp1.IsEqual(&temp2)
}

// Note: This does NOT verify that the point is in the correct subgroup. Currently prints on failure (as it is only used in testing for now anyway)
func (p *Point_xtw) verify_Point_on_Curve() bool {
	if p.IsSingular() {
		fmt.Println("Singular Point encountered")
		return false
	}
	var u, v FieldElement
	u.Mul(&p.x, &p.y)
	v.Mul(&p.t, &p.z)
	if !u.IsEqual(&v) {
		fmt.Println("Point with inconsistent coordinates encountered")
		return false
	}
	// We now check the main curve equation.
	u.Mul(&p.t, &p.t)
	u.MulEq(&TwistedEdwardsD_fe) // u = d*t^2
	v.Mul(&p.z, &p.z)
	u.AddEq(&v) // u= dt^2 + z^2
	v.Mul(&p.y, &p.y)
	u.SubEq(&v) // u = z^2 + dt^2 - y^2
	v.Mul(&p.x, &p.x)
	v.multiply_by_five()
	u.AddEq(&v) // u = z^2 + dt^2 - y^2 + 5x^2 ==  z^2 + dt^2 - y^2 - ax^2
	if !u.IsZero() {
		fmt.Printf("Point not on curve encountered: x=0x%x y=0x%x z=0x%x t=0x%x", p.x.ToInt(), p.y.ToInt(), p.z.ToInt(), p.t.ToInt())
		return false
	}
	return true
}

// This checks whether the X/Z coordinate may be in the subgroup.
func (p *Point_xtw) legendre_check_point() bool {
	var temp FieldElement
	/// p.MakeAffine()  -- removed in favour of homogenous formula
	temp.Square(&p.x)
	temp.multiply_by_five()
	var zz FieldElement
	zz.Square(&p.z)
	temp.AddEq(&zz) // temp = z^2 + 5x^2 = z^2-ax^2
	tempInt := temp.ToInt()
	result := big.Jacobi(tempInt, BaseFieldSize)
	if result == 0 {
		panic("z^2-ax^2 is 0") // Cannot happen, because a is a non-square.
	}
	return result > 0
}

// clearCofactor4 multiplies a point (which need not be in the subgroup) and multiplies it by the cofactor 4 to ensure the result is in the subgroup.
func (p *Point_xtw) clearCofactor4() {
	p.double_xx(p)
	p.double_xx(p)
}

// clearCofactor4 multiplies a point (which need not be in the subgroup) and multiplies it by 2 to ensure the result is in the subgroup. (The cofactor is 4, but the cofactor group is Z/2 x Z/2, so this is sufficient.)
func (p *Point_xtw) clearCofactor2() {
	p.double_xx(p)
}

// IsSingular checks whether the point is singular (x==y==t==z==0). Singular points must never appear if the library is used correctly. They can appear by
// a) performing operations on points that are not in the correct subgroup
// b) zero-initialized points are singular (Go lacks constructors to fix that).
func (p *Point_xtw) IsSingular() bool {
	return p.z.IsZero() && p.x.IsZero() && p.y.IsZero() && p.t.IsZero()
}

// psi_xx computes the GLV Endomorphism (degree-2 isogeny with kernel {Neutral, Affine oder-2}) on a given input point. It is valid unless input is at infinity.
func (output *Point_xtw) psi_xx(input *Point_xtw) {
	// The formula used below is valid unless for the input xy==zt is zero, which happens iff the input has order 2 or 1.
	if input.x.IsZero() {
		// Since we assume to be on the p253 subgroup, we know that the input is actuall the neutral element, so the output is the neutral element.
		// Note that for the other point with x==0 (i.e. the affine order-2 point), outputting the neutral element is actually correct.
		// To avoid problems, we verify that the input is not singular.
		if input.IsSingular() {
			// TODO: Panic / Log? We set the output to the input to maintain the propery that Operation(singularity) == singularity, i.e. singularity has NaN-like behaviour.
			*output = *input
			return
		}
		*output = NeutralElement_xtw
		return
	}
	var bzz, yy, A, B, C, D FieldElement
	bzz.Square(&input.z)
	yy.Square(&input.y)
	A.Sub(&bzz, &yy)
	A.MulEq(&endo_c_fe) // A = c*(z^2 - y^2)

	bzz.MulEq(&endo_b_fe)
	B.Sub(&yy, &bzz) // B = y^2 - bz^2

	C.Add(&yy, &bzz)
	C.MulEq(&endo_b_fe) // C = b(y^2 + bz^2)

	D.Mul(&input.t, &input.z) // D = t*z == x*y

	output.x.Mul(&A, &B)
	output.y.Mul(&C, &D)
	output.t.Mul(&A, &C)
	output.z.Mul(&B, &D)
}

// psi_xx_safe computes the GLV endomorphism and works for all points.
func (output *Point_xtw) psi_xx_safe(input *Point_xtw) {
	if input.z.IsZero() && !input.IsSingular() {
		*output = orderTwoPoint_xtw
	} else {
		output.psi_xx(input)
	}
}
